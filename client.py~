from requests import session
import tensorflow as tf
import socket
import cv2
import time
import numpy as np
from Crypto.PublicKey import RSA
from Crypto.Random import get_random_bytes
from Crypto.Cipher import AES, PKCS1_OAEP
import random
import threading


#--------------------------------------------
'''
The followings are hard-coded global variables
'''
HEADER = 64
KEY_SIZE = 16
PORT = 5050 #??
FORMAT = 'utf-8'
DISCONNECT_MESSAGE = "!DISCONNECT"
# SERVER = "169.254.155.73"
SERVER = "192.168.56.102"
ADDR = (SERVER, PORT)
SHOULD_CHECK_EYE = False

#--------------------------------------------
def detect_eyes(face_img, classifier):
    gray_frame = cv2.cvtColor(face_img, cv2.COLOR_BGR2GRAY)
    eyes = classifier.detectMultiScale(gray_frame) # detect eyes
    width = np.size(face_img, 1)
    height = np.size(face_img, 0)

    left_eye = None
    right_eye = None

    for (x, y, w, h) in eyes:
        if y > height / 2:
            pass
        else:
            cv2.rectangle(face_img, (x,y),(x+w,y+h),(0,255,0), 2)
            eyecenter = x + (w / 2)
            if eyecenter < width * 0.5:
                left_eye = face_img[y:y+h, x:x+w]
            else:
                right_eye = face_img[y:y+h, x:x+w]
    
    return left_eye, right_eye

def detect_faces(whole_img, classifier):
    gray_frame = cv2.cvtColor(whole_img, cv2.COLOR_BGR2GRAY)
    faces = classifier.detectMultiScale(gray_frame, 1.3, 5)
    if len(faces) > 1:  # More than 1 face detected
        biggest = (0, 0, 0, 0)
        for face in faces:
            if face[3] > biggest[3]:
                biggest = face
        np.expand_dims(biggest, 0)
    
    elif len(faces) == 1:  # Only 1 face detected
        biggest = faces
    else: # No face detected
        return None
    
    if biggest.ndim == 1:
        print(biggest)

    # if biggest.ndim < 2:
    #     return None
    # else:
    for (x,y,w,h) in biggest:
        color_frame = whole_img[y:y+h, x:x+w]
        cv2.rectangle(whole_img, (x,y),(x+w,y+h),(255,0,0), 2)
    
    return color_frame
def send(msg, session_key):
    cipher_aes = AES.new(session_key, AES.MODE_CTR)
    cipher_text = cipher_aes.encrypt(msg.encode("utf-8"))
    message = cipher_aes.nonce + cipher_text

    msg_length = len(message)

    send_length = str(msg_length).encode(FORMAT)
    send_length += b' ' * (HEADER - len(send_length))

    client.send(send_length)
    client.send(message)

def send_heartbeat():
    while True:
        time.sleep(random.randint(1, 10))

        cipher_aes = AES.new(session_key, AES.MODE_CTR)
        cipher_text = cipher_aes.encrypt('!test'.encode("utf-8"))
        message = cipher_aes.nonce + cipher_text

        msg_length = len(message)
        send_length = str(msg_length).encode(FORMAT)

        send_length += b' ' * (HEADER - len(send_length))

        client.send(send_length)
        client.send(message)

def send_key(enc_session_key):
    msg_length = len(enc_session_key)
    send_length = str(msg_length).encode(FORMAT)
    send_length += b' ' * (HEADER - len(send_length))
    client.send(send_length)
    client.send(enc_session_key)

def check_eye():
    global SHOULD_CHECK_EYE 
    while True:
        time.sleep(2)
        SHOULD_CHECK_EYE = True

#--------------------------------------------




#--------------------------------------------
# Connecting to server
client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect(ADDR)
# Conection is established
#--------------------------------------------




#--------------------------------------------
# Generate a secret key and send to server
session_key = get_random_bytes(16)

server_pubkey_file = open('public.pem')
server_pubkey = RSA.import_key(server_pubkey_file.read())
server_pubkey_file.close()

cipher_rsa = PKCS1_OAEP.new(server_pubkey)
enc_session_key = cipher_rsa.encrypt(session_key)

send_key(enc_session_key)
#--------------------------------------------



#--------------------------------------------
# instantiating the AES object for symmetric encryption of everything
cipher_aes = AES.new(session_key, AES.MODE_CTR)
#--------------------------------------------


#--------------------------------------------
# Start sending the heartbeat in a thread
thread = threading.Thread(target=send_heartbeat)
thread.start()
#--------------------------------------------

# Load eye recognization model from file
new_model_1 = tf.keras.models.load_model("trained_model_for_810.h5")

face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')
eye_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_eye.xml')
cap = cv2.VideoCapture(0)  # 0 is self facing

if not cap.isOpened():
    raise IOError("Cannot open webcam")

final_decision = 0
thread1 = threading.Thread(target=check_eye)
thread1.start()
strike = 0
eye_states = []
monitor = []
while True:
    ret, frame = cap.read()
    face = detect_faces(frame, face_cascade)
    if face is not None:
        left_eye, right_eye = detect_eyes(face, eye_cascade)
    cv2.imshow("Alertness Monitor", frame)

    if SHOULD_CHECK_EYE:
        # face = detect_faces(frame, face_cascade)
        if face is not None:
            # left_eye, right_eye = detect_eyes(face, eye_cascade)
            if left_eye is None and right_eye is None: # no eyes are detected from the face
                strike += 1
            else:
                if left_eye is not None:
                    final_image = cv2.resize(left_eye, (224, 224))
                    final_image = np.expand_dims(final_image, axis=0)
                    final_image = final_image / 255
                    eye_states.append(new_model_1.predict(final_image)[0][0] >= .5)
                if right_eye is not None:
                    final_image = cv2.resize(right_eye, (224, 224))
                    final_image = np.expand_dims(final_image, axis=0)
                    final_image = final_image / 255
                    eye_states.append(new_model_1.predict(final_image)[0][0] >= .5)
                print(f"eye state is {eye_states}")
                if not any(eye_states): # all detected eyes closed 
                    strike += 1
                    print("strike given")
                if any(eye_states): # not all eyes closed 
                    print("all eyes are open, resetting strike")
                    strike = 0
                eye_states = []

        else: # no face detected
            strike += 1
        print(f'Strike is {strike}')
        
        if strike == 5:
            strike = 0
            send('sleep', session_key)
            print("wake up!")
            
        print(f'Strike is {strike}')
        SHOULD_CHECK_EYE = False

    # print("hello")
    # print(face)
    # left_eye, right_eye = detect_eyes(face, eye_cascade)
    
    # for(x,y,w,h) in eyes:
    #     cv2.rectangle(gray_frame, (x, y), (x+w, y+h), (0, 255, 0), 2)
        
    # cv2.imshow("Hi there!", gray_frame)
    # if face is not None:
    #     left_eye, right_eye = detect_eyes(face, eye_cascade)
    #     if left_eye is not None:
    #         cv2.imshow("Hi there!", left_eye)
    # else:
    #     # cv2.imshow("Hi there!", frame)
    #     pass

    # if SHOULD_CHECK_EYE:
    #     for (x, y, w, h) in eyes:
            
    #         roi_gray = gray_frame[y:y+h, x:x+w]
    #         eye_candidate = cv2.resize(roi_gray, (224,224))
    #         eye_candidate = cv2.cvtColor(eye_candidate, cv2.COLOR_GRAY2RGB)
    #         # cv2.imshow("Hi there!", eye_candidate)
    #         eye_candidate = np.expand_dims(eye_candidate, axis=0)
    #         eye_candidate = eye_candidate / 255.0
            
    #         temp_d_list.append(new_model_1.predict(eye_candidate)[0][0] >= .5)
    #         # print(temp_d_list)
    #     SHOULD_CHECK_EYE = False
        

# Eye recognization model ends

#--------------------------------------------


# Decision and transmission module
    
    # if len(temp_d_list) != 0 and (sum(temp_d_list) / len(temp_d_list) < .5):
    #     final_decision += 1
    #     print(final_decision)
    
    # if all(temp_d_list) and len(temp_d_list) != 0:
    #     print("sorry, false postitive, reset decision")
    #     final_decision = 0
    # if final_decision == 3:
    #     final_decision = 0
    #     send('sleep', session_key)
    #     print("Whoop whoop!Wake up!")
        
    key = cv2.waitKey(1)
    if key == ord('s'):
        time.sleep(10)
    elif key == ord('r'):
        strike = 0
        print("Manual override")
    elif key == ord('q'):
        break
    else:
        pass
        
# Closing the webcam
cap.release()
cv2.destroyAllWindows()

send(DISCONNECT_MESSAGE, session_key)

